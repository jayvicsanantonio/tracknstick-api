# Development Guide for TracknStick API

This guide provides comprehensive information for developers working on the TrackNStick API project. It covers setup, coding standards, architecture, testing, debugging, and other development-related best practices.

## 1. Introduction

Welcome to the TrackNStick API development team! This guide will help you get started with the project, understand its structure, and contribute effectively. The API is built using Hono.js, running on Cloudflare Workers, with Cloudflare D1 as its database.

## 2. Development Environment Setup

*(Consolidated from `docs/development/setup.md` and `docs/development/README.md`, adapted for Hono/Cloudflare environment)*

### Prerequisites

*   **Node.js:** Version as specified in the project's `.node-version` file (e.g., v20.12.2). It's highly recommended to use `fnm` (Fast Node Manager) for Node.js version management.
    *   **Install `fnm`:** Follow instructions on the [fnm GitHub page](https://github.com/Schniz/fnm). For macOS with Homebrew: `brew install fnm`.
    *   **Configure shell for `fnm`:** Add `eval "$(fnm env --use-on-cd)"` to your shell configuration file (e.g., `~/.zshrc`, `~/.bashrc`) and restart your shell or source the file.
*   **pnpm:** This project uses `pnpm` as its package manager.
    *   **Install `pnpm`:** After setting up Node.js (which includes `npm`), install `pnpm` globally: `npm install -g pnpm`.
*   **Git:** For version control. [Download Git](https://git-scm.com/downloads).
*   **Wrangler CLI:** Cloudflare's command-line tool for developing and deploying Cloudflare Workers.
    *   **Install `wrangler`:** `pnpm install -g wrangler` (or `npm install -g wrangler`).
    *   **Login to Cloudflare:** Authenticate Wrangler with your Cloudflare account: `wrangler login`.
*   **Code Editor:** A modern code editor like VS Code is recommended.
    *   **Recommended VS Code Extensions:** ESLint, Prettier - Code formatter, EditorConfig for VS Code (if a `.editorconfig` file is used). For D1, a SQLite viewer extension that can open `.sqlite` files generated by local Wrangler can be helpful.

### Getting the Source Code & Initial Setup

1.  **Clone the Repository:**
    ```bash
    git clone https://github.com/jayvicsanantonio/tracknstick-api.git # Or your fork URL
    cd tracknstick-api
    ```
2.  **Set Node.js Version:** If you're using `fnm`, navigate into the project directory and run:
    ```bash
    fnm use
    ```
    This command reads the `.node-version` file and activates the specified Node.js version.
3.  **Install Dependencies:** Use `pnpm` to install project dependencies:
    ```bash
    pnpm install
    ```

### Environment Configuration (Cloudflare Workers)

Environment variables for Cloudflare Workers are managed differently for local development versus deployed environments.

1.  **Local Development (`.dev.vars`):**
    *   Create a file named `.dev.vars` in the project root. This file is listed in `.gitignore` and should **not** be committed to version control.
    *   Populate it with necessary environment variables for local development. These often mirror variables you'd set in the Cloudflare dashboard secrets for deployments.
        ```ini
        # .dev.vars (Example)
        CLERK_SECRET_KEY="sk_test_YOUR_CLERK_SECRET_KEY_HERE" # Use your Clerk Test Secret Key
        # CLERK_PUBLISHABLE_KEY="pk_test_YOUR_CLERK_PUBLISHABLE_KEY_HERE" # Usually for frontend, but can be here for reference

        ENVIRONMENT="development" # Or "local", useful for conditional logic in your code

        # Note: D1 Database bindings are configured in wrangler.toml, not usually via direct env vars for connection strings.
        # Other application-specific variables like RATE_LIMIT_WINDOW_MS, RATE_LIMIT_MAX_REQUESTS if needed.
        ```
    *   Replace placeholder values (like Clerk keys) with your actual development keys.

2.  **Deployment (Cloudflare Dashboard/Wrangler Secrets):**
    *   For deployed environments (preview, production), secrets (like `CLERK_SECRET_KEY`) **must** be set using Wrangler CLI secrets or directly in the Cloudflare Workers dashboard:
        ```bash
        wrangler secret put CLERK_SECRET_KEY
        ```
        You'll be prompted to enter the value. This keeps secrets out of `wrangler.toml`.
    *   Non-secret variables can be defined in `wrangler.toml` under `[vars]` or environment-specific sections like `[env.production.vars]`.

3.  **`wrangler.toml` Configuration File:**
    *   This crucial file defines your Worker's name, entry point (`main`), compatibility date, D1 database bindings, KV namespace bindings, etc.
    *   **D1 Database Binding Example:**
        ```toml
        [[d1_databases]]
        binding = "DB" # This is how you access D1 in your code: c.env.DB (in Hono context)
        database_name = "tracknstick-db-prod" # Name of your D1 database in Cloudflare
        database_id = "your-production-d1-database-id"
        # For local development, wrangler dev will use this to emulate or connect
        # For preview environments, you might define a different database_id:
        # preview_database_id = "your-preview-d1-database-id"
        migrations_dir = "migrations" # Points to the directory containing SQL migration files
        ```
    *   Ensure `database_name` and `database_id` in `wrangler.toml` match your actual D1 database setup in Cloudflare.

### Database Setup (Cloudflare D1)

1.  **Create D1 Database (One-time Cloudflare setup):**
    If you haven't already, create your D1 database(s) in the Cloudflare dashboard or using Wrangler:
    ```bash
    wrangler d1 create tracknstick-database-name # Replace with your desired DB name
    ```
    This command will output the `database_id` required for `wrangler.toml`.
2.  **Apply Migrations:**
    *   SQL migration files are located in the `migrations/` directory. These define the schema.
    *   To apply migrations to your **local** D1 instance (used when running `wrangler dev --local`):
        ```bash
        # Ensure 'database_name' in the command matches a D1 DB defined in wrangler.toml
        pnpm run db:migrate:local 
        # Example underlying command: wrangler d1 migrations apply <your-database-name> --local
        ```
    *   To apply migrations to your **remote** D1 database (preview or production, depending on your `wrangler.toml` or command flags):
        ```bash
        pnpm run db:migrate
        # Example underlying command: wrangler d1 migrations apply <your-database-name> --remote
        # (or simply 'wrangler d1 migrations apply <your-database-name>' for the default environment)
        ```
    *   These `pnpm` scripts are typically defined in `package.json` (e.g., `"db:migrate:local": "wrangler d1 migrations apply tracknstick-db --local"`).

### Running the Application Locally

*   **For a fully local development experience (Worker and D1 emulated locally):**
    ```bash
    pnpm run dev # This script usually runs `wrangler dev --local src/index.ts` (or your main entry point)
    ```
    The API will typically be available at `http://localhost:8787` (Wrangler's default). Any D1 operations will use a local SQLite file managed by Wrangler in the `.wrangler/` directory.

*   **To develop locally but connect to a remote D1 database (e.g., a staging/preview D1 instance):**
    ```bash
    # Ensure your wrangler.toml has 'preview_database_id' set for the D1 binding, or configure an environment
    wrangler dev src/index.ts --remote
    ```

## 3. Development Workflow

A consistent workflow enhances collaboration and code quality.

1.  **Branch Management:**
    *   Create feature branches from the main development branch (e.g., `main` or `develop`).
    *   Use descriptive branch names: `feat/user-preferences`, `fix/login-bug`, `docs/update-readme`.
    *   Keep your feature branches up-to-date with the base branch: `git pull origin main` (or `develop`) and merge/rebase.
2.  **Coding Style & Quality:**
    *   **Adhere to Standards:** Follow the "Coding Standards" outlined below.
    *   **Format & Lint:** Before committing, always run `pnpm format` and `pnpm lint` to ensure code consistency and catch issues early.
    *   **Meaningful Names:** Use clear and descriptive names for variables, functions, classes, etc.
    *   **JSDoc Comments:** Add JSDoc comments for public functions, classes, complex logic, and type definitions.
    *   **Modularity:** Keep functions and modules concise and focused on a single responsibility.
3.  **Testing:**
    *   **Write Tests:** Develop unit and integration tests for new features and bug fixes. (See "Testing Guide" section).
    *   **Run Tests Locally:** Execute `pnpm test` frequently during development.
    *   **Maintain Coverage:** Aim to maintain or improve test coverage.
4.  **Debugging:**
    *   Utilize logging, the VS Code debugger (if applicable for Node.js parts), or Cloudflare Workers' debugging tools. (See "Debugging Guide" section).
5.  **Commits & Pull Requests (PRs):**
    *   **Conventional Commits:** Write commit messages following the [Conventional Commits](https://www.conventionalcommits.org/) specification (e.g., `feat: ...`, `fix: ...`, `refactor: ...`, `docs: ...`). This helps in generating changelogs and understanding commit history.
    *   **Atomic Commits:** Keep commits small and focused on a single logical change.
    *   **Pull Requests:** Submit PRs for review before merging to the main branch. Provide clear descriptions of changes and link to any relevant issues.
6.  **Documentation:**
    *   If your changes impact the API, architecture, database schema, or development process, update the relevant documentation files in the `docs/` directory (e.g. [API Reference](./API_REFERENCE.md), [Architecture Document](./ARCHITECTURE.md), [Database Document](./DATABASE.md)).

## 4. Coding Standards

Adherence to consistent coding standards is crucial for maintainability and collaboration.

### Naming Conventions & Code Style
Follow the conventions outlined in the [Main Project Documentation](./INDEX.md#coding-standards) (camelCase/PascalCase for TypeScript, kebab-case for files, snake_case for SQL). Use ESLint and Prettier (`pnpm format`, `pnpm lint`).

### Comments and Documentation
Use JSDoc for public APIs. Explain the "why" not just the "what." Keep `// TODO:` items tracked or resolved.

### Git Practices
Use Conventional Commits. Keep commits atomic and PRs focused.

### API Design (General Principles)

*   **RESTful Principles:** Strive for RESTful API design where appropriate.
*   **Versioning:** API is versioned (e.g., `/api/v1/...`).
*   **Consistent Response Formats:** Use standardized success and error response structures (see [API Reference](./API_REFERENCE.md#standard-response-format)).
*   **HTTP Status Codes:** Use appropriate HTTP status codes for responses.
*   **Documentation:** Keep [API Reference](./API_REFERENCE.md) and related documents up-to-date.

## 5. Project Guidelines & Architectural Principles

This section reiterates and expands on core development philosophies. For a full overview of the system architecture, refer to the [Architecture Document](./ARCHITECTURE.md).

### Architecture & Code Structure
*   **Maintain Layered Architecture:** Strictly adhere to the Hono-based layered structure:
    *   `src/routes/`: Hono router definitions.
    *   `src/controllers/`: Request/response handlers using Hono's Context (`c`).
    *   `src/services/`: Business logic layer.
    *   `src/repositories/`: Data access layer for Cloudflare D1.
    *   `src/middlewares/`: Custom Hono middleware.
    *   `src/validators/`: Zod schemas for input validation.
    *   `src/types/`: TypeScript interfaces and type definitions.
    *   `src/utils/`: Shared utilities (e.g., custom errors, logger).
*   **Dependency Flow:** Uni-directional: `Controllers` -> `Services` -> `Repositories`.
*   **`src/index.ts`:** Main Worker entry point; sets up Hono app, global middleware, and routes.

### Error Handling
*   **Centralized Handler:** Use Hono's error handling capabilities (`app.onError((err, c) => ...)` in `src/index.ts` or a dedicated middleware). See details in the [API Reference](./API_REFERENCE.md#common-http-status-codes-and-error-codes).
*   **Custom Errors:** Throw custom error classes (e.g., `NotFoundError`, `ValidationError` from `src/utils/errors.ts`) in services and repositories.
*   **Standardized Responses:** The error handler should format all errors into a consistent JSON structure as defined in the [API Reference](./API_REFERENCE.md#standard-response-format).

### Input Validation
*   **Zod Schemas:** Define validation rules using Zod in `src/validators/`.
*   **Validation Middleware:** Use a `validateRequest` middleware in route definitions to apply Zod schemas. Validated data should be passed to controllers via Hono's context (`c.set('validatedData', ...)`).

### Database (Cloudflare D1)
*   **Repository Pattern:** All D1 interactions are encapsulated in `src/repositories/`.
*   **Prepared Statements:** Use D1's prepared statements (`db.prepare(...).bind(...)`) to prevent SQL injection.
*   **User Data Isolation:** Always filter queries by `user_id` (Clerk ID) for user-specific data.
*   **Batching/Transactions:** Utilize D1's `batch()` method for atomic operations where appropriate.
*   **Migrations:** Manage schema changes with SQL files in `migrations/` applied via `wrangler d1 migrations apply`. See the [Database Document](./DATABASE.md#3-database-migrations) for more details.
*   **Schema Documentation:** Ensure the [Database Document](./DATABASE.md) is updated with any schema changes.

### Security
*   **Authentication:** Clerk JWTs are verified by `clerkMiddleware`. Authenticated user ID is available in Hono context. See [API Reference](./API_REFERENCE.md#authentication-clerk-jwt).
*   **Authorization:** Implement within services or repositories by checking `user_id` against resource ownership.
*   **Input Validation:** Zod schemas are crucial.
*   **Secrets Management:** Use `.dev.vars` for local development and Wrangler secrets/Cloudflare dashboard for deployed environments.
*   **Dependencies:** Regularly update (`pnpm up`) and audit (`pnpm audit`).
*   **Hono Security Middleware:** Use `hono/secure-headers` and configure `hono/cors` appropriately.

### General Code Quality
*   **Readability & Maintainability:** Prioritize clear, well-documented code.
*   **DRY Principle:** Abstract and reuse common logic.
*   **Consistency:** Follow established project patterns.

## 6. Codebase Implementation Details

This section provides a brief overview of how different components are implemented. For detailed examples and patterns, refer to the source code in the `src/` directory and the [API Examples Document](./API_EXAMPLES.md).

### Routing (`src/routes/`)
Hono is used for defining routes. Routes are typically grouped by resource (e.g., `habits.routes.ts`, `progress.routes.ts`). These routers are then mounted onto the main Hono app in `src/index.ts`.
```typescript
// Example: src/routes/health.ts
import { Hono } from 'hono';
const healthRoutes = new Hono();
healthRoutes.get('/', (c) => c.json({ status: 'ok', version: '1.0.0' }));
export default healthRoutes;
```

### Middleware (`src/middlewares/`)
Custom middleware for Hono. Examples:
*   `clerkMiddleware.ts`: Verifies Clerk JWT and sets `userId` in context.
*   `validateRequest.ts`: Applies Zod schemas to validate request data.
*   `errorHandler.ts`: Global error handler.
*   `requestLogger.ts`: Logs request details.

### Controllers (`src/controllers/`)
Handle HTTP requests using Hono's `Context` (`c`). They extract validated data from `c`, call service methods, and return JSON responses.
```typescript
// Example: src/controllers/health.controller.ts (conceptual, might be simpler)
import { Context } from 'hono';
export const getHealthStatus = (c: Context) => {
  return c.json({ success: true, data: { status: 'healthy', timestamp: new Date().toISOString() } });
};
```

### Services (`src/services/`)
Contain business logic, orchestrating calls to repositories and performing data transformations. They are independent of Hono's `Context`.
```typescript
// Example: src/services/habit.service.ts (conceptual snippet)
import * as habitRepo from '../repositories/habit.repository';
import { D1Database } from '@cloudflare/workers-types';
// ...
export const getAllUserHabits = async (userId: string, db: D1Database) => {
  return await habitRepo.findHabitsByUserId(db, userId);
};
```

### Repositories (`src/repositories/`)
Manage all interactions with Cloudflare D1, using prepared statements.
```typescript
// Example: src/repositories/user.repository.ts (conceptual snippet)
import { D1Database } from '@cloudflare/workers-types';
// ...
export const findUserByClerkId = async (db: D1Database, clerkId: string) => {
  const stmt = db.prepare('SELECT * FROM users WHERE clerk_user_id = ?');
  return await stmt.bind(clerkId).first();
};
```

### Utilities (`src/utils/`)
*   `errors.ts`: Custom error classes (e.g., `NotFoundError`, `ValidationError`).
*   `logger.ts`: Logging utility.
*   Other specific helpers (e.g., date manipulation, calculations).

## 7. Testing Guide

The project uses **Vitest** for unit and integration testing.

### Testing Approach
*   **Unit Tests:** Isolate and test individual functions/modules (services, utils, specific repository methods by mocking D1).
*   **Integration Tests:** Test interactions between components (e.g., API route -> controller -> service -> mocked repository). Hono's `app.request()` method is useful for in-process API testing.

### Directory Structure
Tests are typically co-located with source files in `__tests__` subdirectories or in a top-level `tests/` directory mirroring `src/`. Example: `src/services/__tests__/habit.service.test.ts`.

### Writing Tests
Refer to Vitest documentation. Use `describe`, `it`, `expect`, and `vi` for mocking.
```typescript
// Example: tests/unit/services/example.service.test.ts
import { describe, it, expect, vi } from 'vitest';
// ...
describe('ExampleService', () => {
  it('should do something correctly', () => {
    // ... test logic ...
  });
});
```

### Mocking
*   **Modules/Dependencies:** Use `vi.mock()`.
*   **D1 Database for Repositories/Integration Tests:**
    *   For unit testing repositories, mock the D1 `Database` binding passed to functions.
    *   For integration tests with `app.request()`, provide a mocked D1 binding in the test environment setup or pass it via Hono's `env` property if your app is structured to accept it.
*   **Clerk Authentication:** Mock `clerkMiddleware` in tests to simulate authenticated users.

### Running Tests
*   **All Tests:** `pnpm test`
*   **Specific Tests/Watch Mode:** Refer to Vitest CLI options (`pnpm test -- <pattern>`, `pnpm test --watch`).

### Code Coverage
Configure Vitest for coverage (`vitest run --coverage`). Aim for high coverage of business logic.

## 8. Debugging Guide

### Tools & Strategies
*   **`console.log`:** Effective for quick debugging in Workers; output appears in `wrangler dev` console.
*   **Cloudflare Workers Debugging:**
    *   `wrangler dev --inspect`: Opens a DevTools instance for your local Worker. Set breakpoints, inspect variables.
    *   **Logs in Cloudflare Dashboard:** View live and historical logs for deployed Workers.
*   **Error Handling:** Ensure your global error handler logs detailed error information (especially stack traces in development).
*   **D1 Database Inspection:**
    *   Use `wrangler d1 execute <DB_NAME> --local --command "SELECT * FROM ..."` to query your local D1 instance. (Replace `<DB_NAME>` with the actual database name from `wrangler.toml`, see [Database Document](./DATABASE.md#3-database-migrations) for more on migrations and naming).
    *   For remote D1, use `wrangler d1 execute <DB_NAME> --remote --command "..."`.
*   **Authentication (Clerk):**
    *   Use `jwt.io` to inspect JWTs if needed.
    *   Check Clerk dashboard logs for authentication issues.
    *   Log the `userId` obtained from `c.get('userId')` in Hono context to verify authentication middleware.

### Common Issues
*   **D1 Binding Errors:** Verify `wrangler.toml` bindings and that `c.env.DB` (or your binding name) is correctly accessed.
*   **Clerk Configuration:** Ensure `CLERK_SECRET_KEY` (or relevant JWKS URL for newer Clerk SDKs) is correctly set in `.dev.vars` (local) or as a secret (deployed).
*   **Async/Await:** Double-check that all Promises are properly `await`ed.
*   **CORS:** If making cross-origin requests (e.g., from a local frontend to `wrangler dev`), ensure CORS middleware is correctly configured in Hono.
*   For more common issues and solutions, refer to the [Troubleshooting Guide](./TROUBLESHOOTING.md).

## 9. Maintainability, Performance, Enhancements, Learnings

This information is now primarily integrated into the [Architecture Document](./ARCHITECTURE.md) and [Project Overview in INDEX.md](./INDEX.md#project-overview--refactoring). Refer to those documents for:
*   **Maintainability:** Layered architecture, code organization, readability.
*   **Performance Optimizations:** Async operations, D1 indexing, caching strategies.
*   **Enhancements & Future Work:** Test coverage, API documentation generation.
*   **Learnings & Takeaways:** Value of chosen stack and patterns.

This guide aims to be a living document. Please update it as the project, tools, or best practices evolve.

Last Updated: (Current Date)
